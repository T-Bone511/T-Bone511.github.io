<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <nav class="overlay-nav">
        <div class="nav-left">
            <a href="/" class="nav-link logo-link"><img src="assets/T-Bone logo.png" alt="" class="nav-logo" /></a>
        </div>
        <div class="nav-right">
            <button class="hamburger-menu" id="hamburgerMenu" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <div class="menu-overlay" id="menuOverlay"></div>
    <div class="mobile-menu" id="mobileMenu">
        <a href="/" class="mobile-menu-link">Home</a>
        <a href="music.html" class="mobile-menu-link">Music</a>
        <a href="games.html" class="mobile-menu-link">Games</a>
        <a href="cgi.html" class="mobile-menu-link">CGI/VFX</a>
        <a href="other.html" class="mobile-menu-link">Other Projects</a>
        <a href="#contact" class="mobile-menu-link">Contact</a>
    </div>

    <section class="section section-1">
        <div id="stars"></div>
        <div id="stars2"></div>
        <div id="stars3"></div>
        <div id="threejs-container"></div>
        <div class="typing-text" id="typingText"></div>
    </section>

    <section class="section section-2">
        <div class="section-2-content">
            <h1 class="whoami-header">WhoAmI?</h1>
            <p class="whoami-summary">My name is Titus Persons, known as T-Bone Online, I'm a creative developer and artist from Upstate NY. I am passionate about building interactive experiences, creating music, and exploring the intersection of technology and art.</p>
        </div>
    </section>

    <section class="section section-3">
        <h2 class="section-heading">My Work</h2>
        <div class="cards-container">
            <div class="card card-1">
                <div class="card-top-row">
                    <div class="card-image-wrapper">
                        <img src="assets/CasseteDithered.png" alt="Card 1" class="card-image">
                    </div>
                    <div class="card-title-wrapper">
                        <h3 class="card-title">Music</h3>
                    </div>
                </div>
                <div class="card-divider"></div>
                <p class="card-paragraph">I write and produce my own music, I'm completely self-taught and use basic equipment and software to create my tracks.</p>
                <div class="card-divider"></div>
                <a href="music.html" class="card-button">View Projects →</a>
            </div>
            <div class="card card-2">
                <div class="card-top-row">
                    <div class="card-image-wrapper">
                        <img src="assets/DonutDithered.png" alt="Card 2" class="card-image">
                    </div>
                    <div class="card-title-wrapper">
                        <h3 class="card-title">CGI/VFX</h3>
                    </div>
                </div>
                <div class="card-divider"></div>
                <p class="card-paragraph">I create CGI and VFX renders for my own projects and for clients. I use Blender for most of my work.</p>
                <div class="card-divider"></div>
                <a href="cgi.html" class="card-button">View Projects →</a>
            </div>
            <div class="card card-3">
                <div class="card-top-row">
                    <div class="card-image-wrapper">
                        <img src="assets/SpaceDithered.png" alt="Card 3" class="card-image">
                    </div>
                    <div class="card-title-wrapper">
                        <h3 class="card-title">Video Games</h3>
                    </div>
                </div>
                <div class="card-divider"></div>
                <p class="card-paragraph">I create my own video games using Unity and C#.</p>
                <div class="card-divider"></div>
                <a href="games.html" class="card-button">View Projects →</a>
            </div>
            <div class="card card-4">
                <div class="card-top-row">
                    <div class="card-image-wrapper">
                        <img src="assets/MiscDithered.png" alt="Card 4" class="card-image">
                    </div>
                    <div class="card-title-wrapper">
                        <h3 class="card-title">Other Projects</h3>
                    </div>
                </div>
                <div class="card-divider"></div>
                <p class="card-paragraph">I have many other miscellaneous projects that I'm working on, such as this website! also including 3D printing, projection mapping, and alot more.</p>
                <div class="card-divider"></div>
                <a href="other.html" class="card-button">View Projects →</a>
            </div>
        </div>
    </section>

    <section class="section section-4" id="contact">
        <h2 class="section-heading">Contact</h2>
    </section>

    <script>
        // Generate random star positions
        function generateStars(count) {
            let shadows = '';
            for (let i = 0; i < count; i++) {
                const x = Math.random() * 2000;
                const y = Math.random() * 2000;
                shadows += (i > 0 ? ', ' : '') + x + 'px ' + y + 'px #FFF';
            }
            return shadows;
        }

        // Set star shadows
        document.getElementById('stars').style.boxShadow = generateStars(700);
        document.getElementById('stars2').style.boxShadow = generateStars(200);
        document.getElementById('stars3').style.boxShadow = generateStars(100);

        // Typing animation
        const phrases = ["Greetings Program", "Hello There", "Howdy!", "Hello World!",];
        let currentPhraseIndex = 0;
        let currentCharIndex = 0;
        let isDeleting = false;
        const typingElement = document.getElementById('typingText');
        let typingSpeed = 100;

        function typeText() {
            const currentPhrase = phrases[currentPhraseIndex];
            
            if (!isDeleting && currentCharIndex < currentPhrase.length) {
                typingElement.textContent = currentPhrase.substring(0, currentCharIndex + 1);
                currentCharIndex++;
                typingSpeed = 100;
            } else if (isDeleting && currentCharIndex > 0) {
                typingElement.textContent = currentPhrase.substring(0, currentCharIndex - 1);
                currentCharIndex--;
                typingSpeed = 50;
            } else if (!isDeleting && currentCharIndex === currentPhrase.length) {
                // Pause at end of phrase
                typingSpeed = 2000;
                isDeleting = true;
            } else if (isDeleting && currentCharIndex === 0) {
                // Move to next phrase
                isDeleting = false;
                currentPhraseIndex = (currentPhraseIndex + 1) % phrases.length;
                typingSpeed = 500;
            }

            setTimeout(typeText, typingSpeed);
        }

        // Start typing animation
        typeText();

        // 3D Models Animation
        let scene, camera, renderer;
        let models = [];
        let spawnTimes = []; // Array to track multiple spawn times
        let loadedModels = []; // Array to store all loaded models
        const modelFiles = ['Cube.glb', 'Cone.glb', 'Cylinder.glb', 'Sphere.glb', 'Diamond.glb', 'Ico.glb', 'Logo.glb', 'Star.glb']; // List of model files in assets/Models folder
        const spawnInterval = 800; // Base spawn interval (0.8 seconds)
        const modelSpeed = 0.02; // Speed of models moving across (slower)
        const maxModels = 5; // Maximum number of models on screen (one per row)
        const numRows = 5; // Split screen into 5 rows
        const screenMinY = -5; // Extended bottom of screen
        const screenMaxY = 5; // Extended top of screen
        const screenHeight = screenMaxY - screenMinY; // Total screen height
        const rowHeight = screenHeight / numRows; // Height of each row
        let rowOccupied = new Array(numRows).fill(false); // Track which rows have models

        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            if (!container) return;
            
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 0;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Load all models from the Models folder
            const loader = new THREE.GLTFLoader();
            let modelsLoaded = 0;
            const totalModels = modelFiles.length;
            
            if (totalModels === 0) {
                // Fallback if no models
                const now = Date.now();
                for (let i = 0; i < 3; i++) {
                    spawnTimes.push(now + (i * 800));
                }
                animate();
                return;
            }
            
            modelFiles.forEach((modelFile) => {
                loader.load(`assets/Models/${modelFile}`, (gltf) => {
                    const model = gltf.scene.clone();
                    // Scale the model if needed
                    model.scale.set(0.5, 0.5, 0.5);
                    loadedModels.push(model);
                    modelsLoaded++;
                    
                    // Once all models are loaded, start spawning
                    if (modelsLoaded === totalModels) {
                        // Initialize spawn times with very exaggerated random intervals
                        const now = Date.now();
                        // Create more spawn timers with very random initial times
                        for (let i = 0; i < 10; i++) {
                            // Very exaggerated random initial spawns (0 to 8 seconds) - much more spread out
                            spawnTimes.push(now + (Math.random() * 8000));
                        }
                        animate();
                    }
                }, undefined, (error) => {
                    console.error(`Error loading model ${modelFile}:`, error);
                    modelsLoaded++;
                    
                    // If all models failed or all loaded, start anyway
                    if (modelsLoaded === totalModels) {
                        const now = Date.now();
                        for (let i = 0; i < 3; i++) {
                            spawnTimes.push(now + (i * 800));
                        }
                        if (loadedModels.length > 0 || modelsLoaded === totalModels) {
                            animate();
                        }
                    }
                });
            });
        }

        function createModel() {
            // Find available rows (not occupied)
            const availableRows = [];
            for (let i = 0; i < numRows; i++) {
                if (!rowOccupied[i]) {
                    availableRows.push(i);
                }
            }
            
            // If no rows available, can't spawn
            if (availableRows.length === 0) {
                return false;
            }
            
            // Randomly select an available row
            const selectedRow = availableRows[Math.floor(Math.random() * availableRows.length)];
            rowOccupied[selectedRow] = true; // Mark row as occupied
            
            let mesh;
            
            if (loadedModels.length > 0) {
                // Randomly select a model from the loaded models
                const randomIndex = Math.floor(Math.random() * loadedModels.length);
                mesh = loadedModels[randomIndex].clone();
            } else {
                // Fallback to simple geometry if models aren't loaded yet
                const geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const material = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
                    metalness: 0.3,
                    roughness: 0.7
                });
                mesh = new THREE.Mesh(geometry, material);
            }
            
            // Random spawn from left or right
            const spawnFromLeft = Math.random() > 0.5;
            // Spawn much further off-screen to avoid seeing them appear/disappear
            const startX = spawnFromLeft ? -15 : 15;
            const endX = spawnFromLeft ? 15 : -15;
            
            // Calculate Y position for the selected row
            // Rows are from screenMinY to screenMaxY, divided into 5 equal parts
            // Row 0 is bottom, Row 4 is top
            const rowCenterY = screenMinY + (selectedRow * rowHeight) + (rowHeight / 2);
            // Add slight random variation within the row (±0.4)
            const finalY = rowCenterY + (Math.random() - 0.5) * 0.8;
            
            // Random Y position and rotation
            mesh.position.set(startX, finalY, -2);
            mesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            // Store movement data including row info
            mesh.userData = {
                startX: startX,
                endX: endX,
                speed: modelSpeed,
                row: selectedRow, // Store which row this model is in
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                }
            };
            
            scene.add(mesh);
            models.push(mesh);
            return true; // Successfully spawned
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            
            // Spawn new models at very varied times for randomness
            // Only spawn if we don't have too many models on screen
            if (models.length < maxModels) {
                // Check each spawn time
                for (let i = spawnTimes.length - 1; i >= 0; i--) {
                    if (currentTime >= spawnTimes[i]) {
                        const spawned = createModel();
                        if (spawned) {
                            // Very exaggerated random next spawn (0.2 to 6 seconds) for maximum randomness
                            const nextInterval = 200 + (Math.random() * 5800);
                            spawnTimes[i] = currentTime + nextInterval;
                        } else {
                            // If couldn't spawn (all rows full), try again soon but still random
                            spawnTimes[i] = currentTime + 50 + (Math.random() * 500);
                        }
                    }
                }
            } else {
                // If at max models, still update spawn times so they're ready when space opens
                for (let i = spawnTimes.length - 1; i >= 0; i--) {
                    if (currentTime >= spawnTimes[i]) {
                        // Reschedule with very random time for when space might be available
                        spawnTimes[i] = currentTime + 100 + (Math.random() * 1500);
                    }
                }
            }

            // Update and remove models
            for (let i = models.length - 1; i >= 0; i--) {
                const model = models[i];
                const { endX, speed, rotationSpeed, row } = model.userData;
                
                // Move model
                model.position.x += (endX > 0 ? speed : -speed);
                
                // Rotate model
                model.rotation.x += rotationSpeed.x;
                model.rotation.y += rotationSpeed.y;
                model.rotation.z += rotationSpeed.z;
                
                // Remove if out of bounds (further off-screen to avoid seeing them disappear)
                if ((endX > 0 && model.position.x > 15) || (endX < 0 && model.position.x < -15)) {
                    // Free up the row when model is removed
                    if (row !== undefined) {
                        rowOccupied[row] = false;
                    }
                    scene.remove(model);
                    models.splice(i, 1);
                }
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Initialize 3D scene after page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initThreeJS);
        } else {
            initThreeJS();
        }

        // Hamburger menu toggle
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const mobileMenu = document.getElementById('mobileMenu');
        const menuOverlay = document.getElementById('menuOverlay');

        function toggleMenu() {
            hamburgerMenu.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            menuOverlay.classList.toggle('active');
        }

        hamburgerMenu.addEventListener('click', toggleMenu);
        menuOverlay.addEventListener('click', toggleMenu);

        // Close menu when clicking on a link
        const menuLinks = document.querySelectorAll('.mobile-menu-link');
        menuLinks.forEach(link => {
            link.addEventListener('click', () => {
                hamburgerMenu.classList.remove('active');
                mobileMenu.classList.remove('active');
                menuOverlay.classList.remove('active');
            });
        });
    </script>
</body>
</html>
